"""
@author: Julian Cabaleiro
@repository: https://github.com/juliancabaleiro/VCDS_CSV

Module for reading and visualizing data files generated by VCDS.
"""
import pandas as pd
import numpy as np
import dash
from dash import dcc, html, Input, Output, State, no_update
import dash_bootstrap_components as dbc
import plotly.graph_objects as go
import pandas as pd
import json
import re
import csv
import io
import sys 
import traceback
import plotly.express as px

#VCDS

group_names = {
    "0": ["STAMP-0","Intake_temp_[dec]","battery_[dec]","Engine_temp_[dec]","Load_[dec]","lambda_[dec]","NC","NC","Thorttle_[dec]","Ton_[dec]","RPM_[dec]"],
    "1": ["STAMP-1","RPM-1","Engine_temp_[Â°C]","lambda_[V]","Binary_block-1"],
    "2": ["STAMP-2","RPM-2","Ton_[ms]","battery_[V]","Intake_temp_[Â°C]"],
    "3": ["STAMP-3","RPM-3","Load_[%]","Thorttle_[Â°]","IAC_[#step]"],
    "4": ["STAMP-4","RPM-4","vel_decimal_[]","Ignition_[Â°AMPS]","Binary_block-4"],
    "5": ["STAMP-5","RPM-5","EVAP_[%]","Consumption_[%]","Empty"],
    "6": ["STAMP-6","Lambda_[#]","Empty","Empty","Empty"],
    "7": ["STAMP-7","Empty","Empty","Empty","Empty"],
    "1-b": ["STAMP-1","RPM","Intake_temp_[Â°C]","lambda_[V]","Binary_block-1"],
    "2-b": ["STAMP-2","RPM","Ton_[ms]","battery_[V]","Engine_temp_[Â°C]"],
    "3-b": ["STAMP-3","RPM-3","Load_[%]","Ignition_[Â°AMPS]","IAC_[#step]"],
    "4-b": ["STAMP-4","RPM-4","Ignition_[Â°AMPS]","Thorttle_[Â°]","Binary_block-4"],
    "empty": ["vacio","vacio","vacio","vacio","vacio"],
}

BLOQUE_01_DATA = [
    {"Field": "A", "Code": "0", "Function": "No fault"},
    {"Field": "A", "Code": "1", "Function": "One or more faults detected"},
    {"Field": "B", "Code": "0", "Function": "Not used (always '0')"},
    {"Field": "C", "Code": "0", "Function": "A/C Off"},
    {"Field": "C", "Code": "1", "Function": "A/C On"},
    {"Field": "D", "Code": "0", "Function": "Not used (always '0')"},
    {"Field": "E", "Code": "0", "Function": "Lambda control (Closed Loop)"},
    {"Field": "E", "Code": "1", "Function": "Lambda control (Open Loop)"},
    {"Field": "F", "Code": "0", "Function": "Idle"},
    {"Field": "F", "Code": "1", "Function": "Not in idle"},
    {"Field": "G", "Code": "0", "Function": "Idle"},
    {"Field": "G", "Code": "1", "Function": "Above idle"},
    {"Field": "H", "Code": "0", "Function": "Engine temperature above 80Â°"},
    {"Field": "H", "Code": "1", "Function": "Engine temperature below 80Â°"},
]

BLOQUE_04_DATA = [
    {"Field": "A", "Code": "0", "Function": "Cut-off deactivated"},
    {"Field": "A", "Code": "1", "Function": "Cut-off activated"},
    {"Field": "B", "Code": "0", "Function": "Not in idle"},
    {"Field": "B", "Code": "1", "Function": "Idle"},
    {"Field": "C", "Code": "0", "Function": "Throttle closed"},
    {"Field": "C", "Code": "1", "Function": "Throttle partially open"},
    {"Field": "D", "Code": "0", "Function": "Throttle partial load"},
    {"Field": "D", "Code": "1", "Function": "Throttle full load"},
    {"Field": "E", "Code": "0", "Function": "Not used"},
    {"Field": "E", "Code": "1", "Function": "Not used"},
    {"Field": "F", "Code": "0", "Function": "Not used"},
    {"Field": "F", "Code": "1", "Function": "Not used"},
    {"Field": "G", "Code": "0", "Function": "Not used"},
    {"Field": "G", "Code": "1", "Function": "Not used"},
    {"Field": "H", "Code": "0", "Function": "Not used"},
    {"Field": "H", "Code": "1", "Function": "Not used"},
]

def open_csv_1AVP(path, stamp_off= True):
  """
  Open CSV created by the VCDS software relase 23.3.1 (x64), Data version: 20230421 DS346.2
  engine using measure block -08
  The software performs burst acquisition for each block. The block measurements are not synchronized with each other.

  Parameter
  ---------
  path : str
      path for the csv
  stamp_off : bool
      True -> Delete the stamp and column
      False -> add the stamp group column
      
  Returns
  -------
  datos_dic : dict
      Dict with the measured parameters
  metadatos : dict
      Dict with the metadata, info, date, groups

  Notes
  -----
  Only tested with the ECU: MARELLI 1AVP MPSF  DG23

  """
  
  #header parameters
  LINES_METADATA = 4      
  HEADER_ROW_INDEX = 5      
  ENCODING = 'latin-1'
  key_del ="STAMP"
  key_del2 ="NC"
  key_del3 ="vacio"
  metadatos = {}
  list_A = list_B = list_C = [] 
  
  try:
    #header info
    with open(path, mode='r', encoding=ENCODING) as f:
        metadatos_lineas = [next(f) for _ in range(LINES_METADATA)] 
        linea_1_str = metadatos_lineas[0]
        #"VCID"
        match_dt = re.search(r'^(.*?)-VCID', linea_1_str)
        if match_dt:
            metadatos['date'] = match_dt.group(1).strip()
        # bin (VCID)
        match_bin = re.search(r'VCID:([A-F0-9-]+)', linea_1_str)
        if match_bin:
            metadatos['bin'] = match_bin.group(1).strip() 
        # software version
        match_sw = re.search(r'VCDS Version:\s*Release ([\d\.]+\s+\(x64\))', linea_1_str)
        if match_sw:
            metadatos['software_version'] = match_sw.group(1).strip() 
        # data version
        match_data = re.search(r'Data version:\s*([\d]+ DS[\d\.]+)', linea_1_str)
        if match_data:
            metadatos['data_version'] = match_data.group(1).strip()
        #line 2            
        linea_2_campos = list(csv.reader(io.StringIO(metadatos_lineas[1])))[0]
        if len(linea_2_campos) >= 1 and linea_2_campos[0].strip():
            metadatos['engine_code'] = linea_2_campos[0].strip()
        if len(linea_2_campos) >= 3 and linea_2_campos[2].strip():
            metadatos['ecu_model'] = linea_2_campos[2].strip()
        #line 4
        linea_4_str = metadatos_lineas[3]
        linea_sin_marker = linea_4_str.replace('Marker,', '')
        patron_valor = r"Group [A-C]:,?'00(\d)|(Group [A-C]:,?\s*Not Running)"
        coincidencias = re.findall(patron_valor, linea_sin_marker)
        grupos = []
        for captura_digito, captura_not_running in coincidencias:
            if captura_digito:
                grupos.append(int(captura_digito))
            else:
                grupos.append(-1)
       
        metadatos['group_A'] = int(grupos[0])
        metadatos['group_B'] = int(grupos[1])
        metadatos['group_C'] = int(grupos[2])

    #data
    # header=5 (lÃ­nea 6) y encoding='latin-1' 
    df = pd.read_csv(
        path, 
        header=5, 
        encoding='latin-1', 
        sep=','
    )
    #sort the data
    metadatos['marker']=df["Marker"][0]
    df.drop(columns=['Marker'], inplace=True)

    a=str(metadatos['group_A'])
    b=str(metadatos['group_B'])
    c=str(metadatos['group_C'])

    if a == "-1":
        list_A=group_names["empty"]
    else:
        list_A=group_names[a]

    if b == "-1":
        list_B=group_names["empty"]
    else:
        list_B=group_names[b]

    if c == "-1":
        list_C=group_names["empty"]
    else:
        list_C=group_names[c]

    #Some values change their position depending the values blocks
    if "1" in {a,b,c} and "2" in {a,b,c}:
        if a == "1":
            list_A = group_names["1-b"]
        elif b == "1":
            list_B = group_names["1-b"]
        elif c == "1":
            list_C = group_names["1-b"]
        
        if a == "2":
            list_A = group_names["2-b"]
        elif b == "2":
            list_B = group_names["2-b"]
        elif c == "2":
            list_C = group_names["2-b"]
        

    list_final = list_A + list_B + list_C
    if len(list_final) == len(df.columns):
        df.columns = list_final

    datos_dic = df.to_dict(orient='list')
    if stamp_off:
        datos_dic=delete_field(datos_dic,key_del)
        datos_dic=delete_field(datos_dic,key_del2)
        datos_dic=delete_field(datos_dic,key_del3)
    return datos_dic, metadatos
      
  except FileNotFoundError:
      print(f" No file in: {path}")
      return {}
  except Exception as e:
      print(f" Error open_csv_1AVP: {e}")
      traceback.print_exc(file=sys.stdout)
      return {}

#Dash

def delete_field(datos_dic,key_del):
    """
    Delete a specified key in dict

    Parameters
    ----------
    datos_dic : dict
        dict with data
    key_del : str
        Key to delete

    Returns
    -------
    dict
        dict without the specified key
    """
    try:
        claves_a_borrar = [clave for clave in datos_dic.keys() 
                            if clave.startswith(key_del)
        ]
        for clave in claves_a_borrar:
            del datos_dic[clave]
        return datos_dic
    except Exception as e:
        print("Error in delete_field() ",e)
        return datos_dic

def html_metadata(data):
    """
    Format metadata dict to html.Div()

    Parameters
    ----------
    data : dict
        Metadata dict
    
    Retuns
    ------
    html.Div
        Table with metadata
    """
    
    componentes = []
    
    componentes.append(
        html.H5("ðŸ“Š File metada", className="mb-3 text-primary")
    )
    
    for clave, valor in data.items():
        clave_formato = clave.replace('_', ' ').title()
        
        # nan values
        valor_display = valor
        clase_valor = "col-8 text-start pe-2"
        
        if pd.isna(valor) or valor == 'nan':
            valor_display = "N/A"
            clase_valor += " fst-italic text-secondary"

        componentes.append(
            html.Div(
                className="row g-0 py-1 border-bottom", 
                children=[
                    # key column
                    html.Div(
                        f"{clave_formato}:",
                        className="col-4 fw-bold text-muted ps-2" 
                    ),
                    # value column
                    html.Div(
                        valor_display,
                        className=clase_valor
                    )
                ]
            )
        )

    return html.Div(
        className="mt-2 card p-3 shadow-sm", 
        children=componentes
    )

def generar_tabla_dbc_cuadricula(data_list):
    """
    Generate a dbc.Table for the binary info
    """
    
    # Header
    header = [html.Thead(html.Tr([
        html.Th("Field", className="col-3"), 
        html.Th("Code", className="col-2 text-center"), 
        html.Th("Function", className="col-7")
    ]))]
    
    # Table body
    body_rows = []
    for item in data_list:
        body_rows.append(html.Tr([
            html.Td(item['Field'], className="fw-bold"),
            html.Td(item['Code'], className="text-center text-primary"),
            html.Td(item['Function']),
        ]))
    
    return dbc.Table(
        header + [html.Tbody(body_rows)],
        bordered=True,  
        striped=True,   
        hover=False,
        responsive=True,
        className="mb-0 fs-6" 
    )

def tab_ecu_info():
    """
    Create the dbc.Tab with binary info
    """

    contenido_tab = html.Div(
        dbc.CardBody(
            [
            html.H3("Reference Binary Values", className="mb-4 text-center"),
            html.P("ECU: MARELLI 1AVP MPSF DG23.", className="lead text-center mb-5"),
             
            dbc.Row([
                
                # Left table
                dbc.Col(
                    dbc.Card([
                        dbc.CardHeader(html.H4("Block 01 Binary Values", className="mb-0")),
                        generar_tabla_dbc_cuadricula(BLOQUE_01_DATA)
                    ], className="shadow-sm h-100"), 
                    md=6, 
                    className="mb-4"
                ),

                # Rigth table
                dbc.Col(
                    dbc.Card([
                        dbc.CardHeader(html.H4("Block 04 Binary Values", className="mb-0")),
                        generar_tabla_dbc_cuadricula(BLOQUE_04_DATA)
                    ], className="shadow-sm h-100"), 
                    md=6, 
                    className="mb-4"
                ),
            ], className="g-4") 
            ],
            className="p-4" 
        )
    )
    
    return dbc.Tab(
        label='ECU Reference', 
        tab_id='ecu-ref-tab', 
        children=contenido_tab
    )

def dash_app_launch():
    """
    This function launch the dash app for watch the data
    """
    app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

    # App layout
    app.layout = html.Div([
        # Tabs
        dbc.Card(
            dbc.Tabs([
                # Tab 1
                dbc.Tab(label='Data viewer', children=[
                    html.Div([
                        dbc.Card(
                            dbc.CardBody([
                                html.H5("CSV Path for 1AVP MPSF DG23", className="card-title"),
                                dbc.InputGroup([
                                    dbc.InputGroupText("Path:"),
                                    dbc.Input(
                                        id='data-in', 
                                        type='text', 
                                        placeholder="Ej: LOG-01-001-002-003.CSV",
                                        value=r"data\LOG-01-001-002-003.CSV",
                                    ),
                                    dbc.Button("Load", id="load-but", color="primary", n_clicks=0)
                                    ],
                                    className="mb-2"
                                ),
                                html.Div(id='load-div', className="mt-2"),
                                html.Br(),
                                html.H5("Paramters selection", className="card-title"),
                                html.P(
                                    "Select one o more fieldss",
                                    className="card-text text-muted"
                                ),
                                dcc.Dropdown(
                                    id='parameters-drp',
                                    options=[],
                                    value=None,
                                    multi=True,
                                    placeholder="Select paramters"
                                ),
                            ]),
                        className="shadow mb-4",
                        ),
                    ])
                ]),
                # Tab 2
                tab_ecu_info(),
            ]),
            className="m-3",),
        # Graph
        dcc.Graph(id='data-plt',
                  ),
        dcc.Store(id='data-store', data={'df_json': None, 'columns': []}),
    ])  

    # Callbacks
    @app.callback(
    [Output(component_id='data-store', component_property='data'),
     Output(component_id='load-div', component_property='children')],
    [Input(component_id='load-but', component_property='n_clicks')],
    [State(component_id='data-in', component_property='value')]
    )
    def load_data(n_clicks, filepath):
        """Load the data in dcc.store """
        datos={}

        if n_clicks is None or n_clicks == 0:
            return {'df_json': None, 'columns': []}, html.P("Put the path and press load.", className="text-info")

        datos, meta = open_csv_1AVP(filepath)

        # Message
        if datos is not {}:
            status_message = html.P("ok", className="text-danger font-weight-bold")
            status_message = html_metadata(meta)
        else:
            status_message = html.P("Error", className="text-success font-weight-bold")

        return {'df_json': json.dumps(datos), 'columns': list(datos.keys())}, status_message
    
    @app.callback(
    [Output(component_id='parameters-drp', component_property='options'),
     Output(component_id='parameters-drp', component_property='value')],
    [Input(component_id='data-store', component_property='data')]
    )
    def update_dropdown(data):
        """Update the dropdown curves."""

        columnas = data.get('columns', [])

        if not columnas:
            return [], None

        # Excluir 'TIME' para graficar
        columnas_graficables = [col for col in columnas if col != 'TIME']
        columnas_graficables =columnas

        options = [{'label': col, 'value': col} for col in columnas_graficables]

        # Default col
        default_value = [columnas_graficables[0]] if columnas_graficables else None 

        return options, default_value
    
    @app.callback(
    Output(component_id='data-plt', component_property='figure'),
    [Input(component_id='parameters-drp', component_property='value')],
    [State(component_id='data-store', component_property='data')]
    )
    def update_graph(columnas_seleccionadas, data):
        """Update the plot"""

        df_json = data.get('df_json')

        # Si no hay datos cargados o no hay columnas seleccionadas
        if df_json is None or not columnas_seleccionadas:
            return px.scatter(
                title="No data", 
                height=500
            )
        try:
            df_dict = json.loads(df_json)
            df_logs = pd.DataFrame(df_dict)
        except Exception as e:
            print(f"Error DF: {e}", file=sys.stderr)
            return px.scatter(title="Error.", height=500)

        # El eje X siempre es 'TIME'
        # Asegurarse de que las columnas seleccionadas realmente existan en el DF
        valid_cols = [col for col in columnas_seleccionadas if col in df_logs.columns]

        if not valid_cols:
            return px.scatter(title="Select a valid parameter.", height=500)
        
        fig = go.Figure()
        offset = 0.08 
            
        # 1. Iterar sobre cada columna seleccionada para crear su traza y su eje Y
        for i, col in enumerate(valid_cols):

            # First Y axis
            if i == 0:
                trace_yaxis_ref = 'y'         
                layout_yaxis_key = 'yaxis'    
                side = 'left'
                position = 0.0
                title = valid_cols[0] 
            else:
                trace_yaxis_ref = f'y{i + 1}' 
                layout_yaxis_key = f'yaxis{i + 1}' 
                side = 'right'
                # No needed
                position = 1.0 - (i * offset) 
                title = col

                #Set the others Y axis
                fig.update_layout(
                    {
                        layout_yaxis_key: dict(
                            visible=False,
                            title='',                     
                            overlaying='y',               
                            side=side,            
                            position=position,    
                            showgrid=False,       
                            zeroline=False,
                            showline=False,               
                            showticklabels=False,         
                        )
                    }
                )

            #add trace
            fig.add_trace(
                go.Scatter(
                    y=df_logs[col], 
                    name=col,
                    yaxis=trace_yaxis_ref, 
                    mode='lines+markers'
                )
            )

        # Layout
        first_trace = fig.data[0]
        first_trace_color = 'black'
        if hasattr(first_trace, 'line') and first_trace.line:
             first_trace_color = first_trace.line.color
        elif hasattr(first_trace, 'marker') and first_trace.marker:
             first_trace_color = first_trace.marker.color

        fig.update_layout(
            title={
                'text': 'Parameters vs. Time',
                'y': 0.95,  
                'x': 0.5,   
                'xanchor': 'center',
                'yanchor': 'top',
                'font': {
                    'size': 20,       
                    'color': 'black'  
                }
                },
            template="plotly_white",

            xaxis=dict(
                title='Time [#samples]', 
                domain=[0.0, 1.0],
                title_font=dict(
                    size=16, 
                    color="darkblue" 
                ),
                tickfont=dict(
                    size=14, 
                    color="black"
                )
                
            ),

            # First Y axis
            yaxis=dict(
                title={
                    #'text': valid_cols[0], 
                    'text': "Parameters [units in the trace name]", 
                    'font': {'color': first_trace_color,
                             'size': 20} 
                },
                showgrid=True,
                zeroline=False,
                tickfont=dict(
                    color=first_trace_color,
                    size=14  
                ),
            ),

            legend_title_text='Parameters',
            font=dict(family="Inter", size=12),
            margin=dict(l=40, r=40 + (len(valid_cols) - 1) * 20, t=60, b=40),
            height=500
        )

        return fig
    
    app.run(debug=True)

if __name__ == '__main__':
    
    dash_app_launch()